<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="SPARQLQueries" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="68.0, 32.0">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={521, 111, 1191, 632}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[957, 522]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0000000000000002">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{483.49999999999994, 255.18164062500006}">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Examples of the four types of SPARQL queries that&#10;return responses from a semantic repository.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[160.0, 25.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="For this model to work, you must first start an instance of&#10;a semantic repository (with data) named &quot;FirstRepo&quot; on localhost &#10;port 7200. For example, try graphDB http://graphdb.ontotext.com/&#10;with the sample dataset that comes with the download.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[120.0, 305.0]">
        </property>
    </property>
    <entity name="SingleEvent" class="ptolemy.actor.lib.SingleEvent">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[90.0, 260.0]">
        </property>
    </entity>
    <entity name="StringConst" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="CONSTRUCT {?s ?p ?o} WHERE {?s ?p ?o} LIMIT 10">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[340.0, 100.0]">
        </property>
    </entity>
    <entity name="Display" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={448, 348, 792, 373}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[792, 329]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[710.0, 260.0]">
        </property>
    </entity>
    <entity name="StringConst2" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="SELECT * WHERE {?s ?p ?o} LIMIT 10">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[275.0, 260.0]">
        </property>
    </entity>
    <entity name="StringConst3" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="DESCRIBE ?x WHERE { ?x ?p ?o } LIMIT 10">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[315.0, 140.0]">
        </property>
    </entity>
    <entity name="StringConst4" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="ASK {?s ?p ?o}">
        </property>
        <doc>Create a constant sequence with a string value.</doc>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="80">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[240.0, 180.0]">
        </property>
    </entity>
    <entity name="SemanticRepository" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="/** Perform a SPARQL query on a semantic repository such as GraphDB.&#10; * &#10; *  SPARQL is a W3C standard for querying semantic repositories,&#10; *  playing an analogous role to SQL with respect to relational&#10; *  databases. Semantic repositories fall within the domain of knowledge&#10; *  representation in AI and typically are implemented as a triplestore:&#10; *  entries in the repository have the form &quot;subject&quot;, &quot;predicate&quot;, &quot;object&quot;&#10; *  eg. &quot;An Apple&quot; &quot;IsA&quot; &quot;Fruit&quot;&#10; *  &#10; *  An example SPARQL query to get a list of up to 100 triples in the repository:&#10; *&#10; *  select * where { &#10; *      ?s ?p ?o .&#10; *  } limit 100&#10; *&#10; *  Documentation for SPARQL and the SPARQL Protocol can be found at&#10; *  https://www.w3.org/TR/rdf-sparql-query/&#10; *&#10; *  Information on GraphDB can be found at&#10; *  http://graphdb.ontotext.com/&#10; *  &#10; *  SPARQL is also a protocol for communicating with RDF databases&#10; *  Upon receiving a query input, this accessor performs an http GET&#10; *  to the specified server and port with the querystring &quot;query&quot; set to the&#10; *  query input. The JSON response from the semantic repository (if any) is &#10; *  sent to the response output. Depending on the query type, the &#10; *  response will be JSON &#10; *&#10; *  This accessor does not block waiting for the response, but if any additional&#10; *  *query* input is received before a pending request has received a response&#10; *  or timed out, then the new request will be queued and sent out only after&#10; *  the pending request has completed. This strategy ensures that outputs are&#10; *  produced in the same order as the input requests.&#10; *&#10; *  @accessor services/SemanticRepository&#10; *  @author Matt Weber&#10; *  @version $$Id: SemanticRepository.js 1725 2017-05-19 22:59:11Z cxh $$&#10; *  @input {string} query The SPARQL query to be sent to the semantic repository.&#10; *   Types of queries yielding a response are: SELECT, CONSTRUCT, ASK, and DESCRIBE&#10; *  @parameter {string} host The URL for the semantic repository.&#10; *  @parameter {string} port The port for the semantic repository.&#10; *  @parameter {string} repositoryName The name of the particular repository on the host.&#10; *  @parameter {int} timeout The amount of time (in milliseconds) to wait for a response&#10; *   before triggering a null response and an error. This defaults to 20000.&#10; *  @output response An object containing the raw response from the service conforming&#10; *   to the SPARQL protocol. If the query type was SELECT or ASK the response will be&#10; *   JSON &quot;sparql-results&quot;. If the query type was CONSTRUCT or DESCRIBE the response&#10; *   will be JSON &quot;rdf&quot;.&#10; */&#10;&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals addInputHandler, addInputParameter, console, error, exports, extend, input, get, getParameter, getResource, output, parameter, send */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10; &#10; /** Set up the accessor by defining the inputs and outputs.&#10; */&#10;exports.setup = function () {&#10;    this.extend('net/REST');&#10;    this.input('query', {&#10;        'type': 'string'&#10;    });&#10;&#10;    this.parameter('host', {&#10;        'type': 'string',&#10;        'value': 'localhost'&#10;    });&#10;&#10;    this.parameter('port', {&#10;        'type': 'int',&#10;        'value': 7200&#10;    });&#10;&#10;    this.parameter('repositoryName', {&#10;        'type': 'string',&#10;    });&#10;&#10;    //Overriding inherited default timeout value of 5000ms to allow for longer queries by default&#10;    this.parameter('timeout', {&#10;        'type': 'int',&#10;        'value': 20000&#10;    });&#10;&#10;    //Use the response output from the REST accessor&#10;&#10;&#10;    // Change default values of the base class inputs.&#10;    // Also, hide base class inputs, except trigger.&#10;    this.input('options', {&#10;        'visibility': 'expert',&#10;    });&#10;    this.input('command', {&#10;        'visibility': 'expert',&#10;    });&#10;    this.input('arguments', {&#10;        'visibility': 'expert',&#10;    });&#10;    this.input('body', {&#10;        'visibility': 'expert'&#10;    });&#10;    this.input('trigger', {&#10;        'visibility': 'expert'&#10;    });&#10;    this.output('headers', {&#10;        'visibility': 'expert'&#10;    });&#10;    this.output('status', {&#10;        'visibility': 'expert'&#10;    });&#10;    this.parameter('outputCompleteResponseOnly', {&#10;        'visibility': 'expert'&#10;    });&#10;};&#10;&#10;//Overriding REST&#10;exports.filterResponse = function(response){&#10;    var realResponse = &quot;&quot;;&#10;    for(var i=0; i &lt; response.length; i++){&#10;        realResponse += String.fromCharCode(response[i]);&#10;    }&#10;    return JSON.parse(realResponse)&#10;}&#10;&#10;//Overriding REST&#10;//Connections to the SemanticRepository should be closed once data has been received.&#10;exports.handleResponse = function(message){&#10;     exports.ssuper.handleResponse.call(this, message);&#10;     exports.ssuper.wrapup();&#10;}&#10;&#10;exports.initialize = function(){&#10;    exports.ssuper.initialize.call(this);&#10;    var thiz = this;&#10;&#10;    this.addInputHandler('query', function(){&#10;        var queryInput = thiz.get('query');&#10;        var host = thiz.getParameter('host');&#10;        var port = thiz.getParameter('port');&#10;        var repositoryName = thiz.getParameter('repositoryName');&#10;&#10;        var options = {&#10;            'headers' : {'Accept':'application/sparql-results+json, application/rdf+json'},&#10;            'method'  : 'GET',&#10;            'url'     : {'host'  : host,&#10;                        'port'   : port,&#10;                        }&#10;        };&#10;&#10;        var command = 'repositories/' + repositoryName;&#10;        var args = {'query' : queryInput} ;&#10;&#10;        thiz.send('options', options);&#10;        thiz.send('command', command);&#10;        thiz.send('arguments', args);&#10;        thiz.send('trigger', true);&#10;    });&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/matt.weber/ptII/org/terraswarm/accessor/accessors/web/services/SemanticRepository.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Perform a SPARQL query on a semantic repository such as GraphDB.&lt;/p&gt;&#10;&lt;p&gt; SPARQL is a W3C standard for querying semantic repositories,&#10; playing an analogous role to SQL with respect to relational&#10; databases. Semantic repositories fall within the domain of knowledge&#10; representation in AI and typically are implemented as a triplestore:&#10; entries in the repository have the form &amp;quot;subject&amp;quot;, &amp;quot;predicate&amp;quot;, &amp;quot;object&amp;quot;&#10; eg. &amp;quot;An Apple&amp;quot; &amp;quot;IsA&amp;quot; &amp;quot;Fruit&amp;quot;&lt;/p&gt;&#10;&lt;p&gt; An example SPARQL query to get a list of up to 100 triples in the repository:&lt;/p&gt;&#10;&lt;p&gt; select * where { &#10;     ?s ?p ?o .&#10; } limit 100&lt;/p&gt;&#10;&lt;p&gt; Documentation for SPARQL and the SPARQL Protocol can be found at&#10; https://&lt;a href=&quot;http://www.w3.org/TR/rdf-sparql-query/&quot;&gt;www.w3.org/TR/rdf-sparql-query/&lt;/a&gt;&lt;/p&gt;&#10;&lt;p&gt; Information on GraphDB can be found at&#10; http://graphdb.ontotext.com/&lt;/p&gt;&#10;&lt;p&gt; SPARQL is also a protocol for communicating with RDF databases&#10; Upon receiving a query input, this accessor performs an http GET&#10; to the specified server and port with the querystring &amp;quot;query&amp;quot; set to the&#10; query input. The JSON response from the semantic repository (if any) is &#10; sent to the response output. Depending on the query type, the &#10; response will be JSON &lt;/p&gt;&#10;&lt;p&gt; This accessor does not block waiting for the response, but if any additional&#10; &lt;em&gt;query&lt;/em&gt; input is received before a pending request has received a response&#10; or timed out, then the new request will be queued and sent out only after&#10; the pending request has completed. This strategy ensures that outputs are&#10; produced in the same order as the input requests.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Matt Weber">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id: SemanticRepository.js 1725 2017-05-19 22:59:11Z cxh $$">
            </property>
            <property name="query (port)" class="ptolemy.kernel.util.StringAttribute" value="The SPARQL query to be sent to the semantic repository.&#10;  Types of queries yielding a response are: SELECT, CONSTRUCT, ASK, and DESCRIBE">
            </property>
            <property name="response (port)" class="ptolemy.kernel.util.StringAttribute" value="An object containing the raw response from the service conforming&#10;  to the SPARQL protocol. If the query type was SELECT or ASK the response will be&#10;  JSON &quot;sparql-results&quot;. If the query type was CONSTRUCT or DESCRIBE the response&#10;  will be JSON &quot;rdf&quot;.">
            </property>
            <property name="host (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The URL for the semantic repository.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port for the semantic repository.">
            </property>
            <property name="repositoryName (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The name of the particular repository on the host.">
            </property>
            <property name="timeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of time (in milliseconds) to wait for a response&#10;  before triggering a null response and an error. This defaults to 20000.">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[530.0, 260.0]">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="options" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="command" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="arguments" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="host" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="repositoryName" class="ptolemy.data.expr.Parameter" value="FirstRepo">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="options" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="command" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="arguments" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="body" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="status" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="headers" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="query" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="SingleEvent.output" relation="relation"/>
    <link port="Display.input" relation="relation3"/>
    <link port="StringConst2.output" relation="relation4"/>
    <link port="StringConst2.trigger" relation="relation"/>
    <link port="SemanticRepository.response" relation="relation3"/>
    <link port="SemanticRepository.query" relation="relation4"/>
</entity>
