<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="LifxSimpleDemo" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-115.0, -15.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={286, 142, 1209, 768}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[977, 675]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.1766044906027808">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{205.30299084393346, 213.63955965909082}">
    </property>
    <property name="enableBackwardTypeInference" class="ptolemy.data.expr.Parameter" value="false">
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Simple demo that discovers the available Lifx light bulbs on the local area network,&#10;configures the first discovered one, and then toggles the light on and off 3 times.&#10;If the bulbs are already setup (through the Lifx mobile app for example), then you &#10;need to be connected to the same LAN. Otherwise, you can connect to the lifx &#10;network (that will be an open Wifi network with a name like &quot;LIFX_Axx_xxxxxx&quot;, and &#10;then run the demo.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-15.0, -30.0]">
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="In order to perform a manual light bulb setup, you can use ManualSetup JS Actor. &#10;For this, 'configuration' output  needs to be connected to the Lifx 'manualBulbSetup'&#10;input. After setting the parameters (ipAddress, port, macAddress and userName), &#10;and receiving a trigger signal, the light can be controled. Don't forget to keep the &#10;inputs 'triggerDiscovery' and 'selectLight' disconnected.&#10; ">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-15.0, 380.0]">
        </property>
    </property>
    <entity name="AlternateOnOff" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;var cmd = [];&#10;var i = 0;&#10;&#10;cmd.push({&#10;	'on': true,&#10;	'color': {&#10;		'bri': 2000,&#10;		'hue': 2000,&#10;		'sat': 2000&#10;	}&#10;});&#10;&#10;cmd.push({&#10;	'on': false,&#10;});&#10;&#10;cmd.push({&#10;	'on': true,&#10;	'color': {&#10;		'bri': 4000,&#10;		'hue': 4000,&#10;		'sat': 4000&#10;	}&#10;});&#10;&#10;cmd.push({&#10;	'on': false,&#10;});&#10;&#10;cmd.push({&#10;	'on': true,&#10;	'color': {&#10;		'bri': 6000,&#10;		'hue': 6000,&#10;		'sat': 6000&#10;	}&#10;});&#10;&#10;cmd.push({&#10;	'on': false,&#10;});&#10;&#10;exports.setup = function () {&#10;	this.output('generateCmd', {&#10;		'type': 'JSON',&#10;		'value': {}&#10;	});&#10;}&#10;&#10;exports.initialize = function () {&#10;	var thiz = this;&#10;	&#10;	var handle = setInterval(function () {&#10;		thiz.send('generateCmd', cmd[i]);&#10;		i++; &#10;		if (i === cmd.length) {&#10;			i = 0;&#10;		}&#10;	}, 2500);&#10;	&#10;	setTimeout(function() {&#10;		clearInterval(handle);&#10;	}, 16000);&#10;}&#10;&#10;&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-150.0, 125.0]">
        </property>
        <port name="generateCmd" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
    </entity>
    <entity name="TestSpontaneousOnce" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Test accessor that spontaneously produces outputs once.&#10;//&#10;// Copyright (c) 2016-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** Test accessor that spontaneously produces outputs once per time interval.&#10; *  This implementation produces a counting sequence.&#10; *&#10; *  @accessor test/TestSpontaneousOnce&#10; *  @parameter delay The delay in milliseconds before the value is outputk.&#10; *  @parameter value The value to be output after the delay.&#10; *  @output output The output port&#10; *  @author Christopher Brooks and Edward A. Lee. Based on TestSpontaneous by Edward A. Lee&#10; *  @version $$Id: TestSpontaneousOnce.js 1659 2017-05-09 14:26:57Z cxh $$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals clearTimeout, console, error, exports, require, setTimeout */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;exports.setup = function () {&#10;    this.parameter('delay', {&#10;        'type': 'number',&#10;        'value': 1000&#10;    });&#10;    this.parameter('value', {&#10;        'value': true&#10;    }); &#10;    this.output('output');&#10;};&#10;&#10;// These variables will not be visible to subclasses.&#10;var handle = null;&#10;&#10;exports.initialize = function () {&#10;    // Need to record 'this' for use in the callback.&#10;    var thiz = this;&#10;    handle = setTimeout(function () {&#10;        thiz.send('output', thiz.getParameter('value'));&#10;    }, this.getParameter('delay'));&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (handle) {&#10;        clearTimeout(handle);&#10;        handle = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/test/TestSpontaneousOnce.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Test accessor that spontaneously produces outputs once per time interval.&#10; This implementation produces a counting sequence.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Christopher Brooks and Edward A. Lee. Based on TestSpontaneous by Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id: TestSpontaneousOnce.js 1659 2017-05-09 14:26:57Z cxh $$">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="The output port">
            </property>
            <property name="delay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The delay in milliseconds before the value is outputk.">
            </property>
            <property name="value (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The value to be output after the delay.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-150.0, 215.0}">
        </property>
        <property name="delay" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Display" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={96, 756, 1706, 227}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[1706, 202]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[505.0, 205.0]">
        </property>
    </entity>
    <entity name="ManualSetup" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;exports.setup = function () {&#10;	this.input('trigger');&#10;	this.output('configuration', {&#10;		'type': 'JSON',&#10;		'value': {}&#10;	});&#10;	&#10;	this.parameter('ipAddress', {&#10;		type: 'string',&#10;		value: '192.168.0.0'&#10;	});&#10;	this.parameter('port', {&#10;		type: 'int',&#10;		value: 56700&#10;	});&#10;	this.parameter('macAddress', {&#10;		type: 'string',&#10;		value: '00000000'&#10;	});&#10;	this.parameter('userName',  {&#10;		type: 'string',&#10;		value: 'abcdefgh'&#10;	});&#10;}&#10;&#10;exports.initialize = function () {&#10;	this.addInputHandler('trigger', function() {&#10;		this.send('configuration', {'ipAddress': this.getParameter('ipAddress'),&#10;				'port': this.getParameter('port'),&#10;				'macAddress': this.getParameter('macAddress')});&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-105.0, 420.0]">
        </property>
        <property name="ipAddress" class="ptolemy.data.expr.Parameter" value="192.168.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="macAddress" class="ptolemy.data.expr.Parameter" value="00000000">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="userName" class="ptolemy.data.expr.Parameter" value="abcdefgh">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="configuration" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
    </entity>
    <entity name="Lifx" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** This accessor discovers and controls one of the available Lifx light bulbs &#10; *  in a local area network using Wifi. The host need to be connected to the &#10; *  same LAN. The setup (configuring the light with a certain Wifi network &#10; *  credentials) is not supported. It can be done using the Lifx mobile app.&#10; *  However, it is possible to run discovery and control the light, even if &#10; *  not setup. For this, you need to connected to the Lifx Wifi. The drawback  &#10; *  is that discovery is limited to only one bulb, the one you are connected &#10; *  to its network.&#10; *&#10; *  While it is possible to interact with Lifx bulbs over the Internet by &#10; *  sending HTTP requests to the Cloud, this module does not provide such&#10; *  mechanism.&#10; *&#10; *  The communication with Lifx light bulbs is done over UDP/IP. Messages are &#10; *  arrays of numeric bytes ordered in little-endian. The packets construction&#10; *  can be found in this link:&#10; *  https://lan.developer.lifx.com/docs/introduction&#10; * &#10; *  Upon initialization, this accessor creates a UDP socket for communication.&#10; *  There are two ways to configure this accessor in order to control a bulb:&#10; *  * the first one consists on discovering Lifx bulbs on the network and then &#10; *    selecting the one to use.&#10; *  * the second is by running a manual setup, where the light parameters are&#10; *    received in the input port. A use case of this scenario is when a server &#10; *    sends information about available devices and their parameters.&#10; *    &#10; *  Discovery starts if an input is provided in 'triggerDiscovery' input port. &#10; *  The accessor will broadcast discovery messages. Since available bulbs will &#10; *  be asynchronously sending State messages, the accessor will be listening.&#10; *  Discovery messages will be repeatedly sent every 'discoveryInterval'&#10; *  parameter value, if no device has been selected. Each newly discovered &#10; *  light bulb will be added to discoveredLifxLights array. Selecting a device  &#10; *  is done by providing the index of the LifxLight in the array of discovered &#10; *  devices in the input port 'selectLight'.&#10; *  &#10; *  Once the light bulb is chosen and successfully configured, discovery will &#10; *  stop and the accessor will start to react to 'commands' input.&#10; *  &#10; *  A LifxLight is a class that has the following parameters:&#10; *  * **ipAddress**: IP address of the bulb in the LAN.&#10; *  * **port**: integer. It defaults to 56700 as noted in the Lifx developer&#10; *      API.&#10; *  * **macAddress**: a string of 12 hex numbers (6bytes) that refer to the &#10; *      bulb macAddress.&#10; *  * **color**: the current color.&#10; *  * **power**: if true, then the bulb is switched on, false if switched off.&#10; *  * **userName**: this is the name of the user. It can be used to filter the &#10; *      received messages.&#10; *      &#10; *  LifxLight class declares a set of functions for light control:&#10; *  * **swithOn()**: switches the light on. The latest selected color is the one&#10; *      used.&#10; *  * **swithOff()**: switches the light off.&#10; *  * **setColor()**: changes the light color.&#10; *  &#10; *  The *commands* input is a JSON object that may have the following properties:&#10; *  * on: true to turn on; false to turn off.&#10; *  * bri: Brightness.  range 0 to 65535.&#10; *  * hue: Color, for bulbs that support color. This is a number in the&#10; *    range 0-65535.&#10; *  * sat: Saturation, for bulbs that support color. This is a number in the&#10; *    range 0-65535.&#10; *&#10; *  HSBK is used to represent the color and color temperature of a light. The&#10; *  color is represented as an HSB (Hue, Saturation, Brightness) value.&#10; *  Please refer to https://en.wikipedia.org/wiki/HSL_and_HSV&#10; *&#10; *  In order to provide mechanisms for fault tolerance, all exchanged messages &#10; *  will request acknowledgment.&#10; *  TODO: Add mechanisms for detecting a fault occurrence &#10; *&#10; *  @accessor devices/Lifx&#10; *  @input {JSON} commands JSON commands for the Hue, for example,&#10; *                {&quot;on&quot; : false, &quot;hue&quot; : 120}&#10; *                &#10; *  @output {string} state outputs the received information from the bulb&#10; *  @parameter {string} ipAddress the IP address of the bulb, returned by the discovery &#10; *   mechanism&#10; *  @parameter {int} port the port number for the communication with the bulb. This&#10; *   parameter defaults to 56700, as specified by the Lifx API&#10; *  @parameter {string} macAddress the MAC address of the bulb, returned by the discovery &#10; *   mechanism&#10; *  @parameter {string} listeningIpAddress the IP address fo rthe accessor to listen to the&#10; *   bulb packets. This defaults to 0.0.0.0 to listen to all UDP packets. &#10; *  @parameter {int} listeningPort the port number for listening. If a swarmlet is using two &#10; *   or more instances of Lifx accessor, than each one needs to have its own distinct listening &#10; *   port.&#10; *  @author Chadlia Jerad&#10; *  @version $$Id: Lifx.js 1597 2017-04-29 15:41:50Z cxh $$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals alert, clearTimeout, console, error, exports, httpRequest, require, setTimeout  */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var udpSocket = require('@accessors-modules/udp-socket');&#10;&#10;var socket = null;&#10;var running = false;&#10;var lifxLightBulb = null;&#10;var handleDiscovery;&#10;var discoveredLifxLights = [];&#10;var discoveryMode = false;&#10;&#10;exports.setup = function () {&#10;	// Inputs&#10;&#10;	this.input('triggerDiscovery');&#10;	this.input('selectLight', {&#10;		'type': 'int',&#10;		'value': 0&#10;	});&#10;	this.input('commands', {&#10;		'type': 'JSON',&#10;		'value': {}&#10;	});&#10;	this.input('manualBulbSetup', {&#10;		'type': 'JSON',&#10;			'value': {}&#10;	});&#10;&#10;	&#10;	// Outputs&#10;	this.output('state', {&#10;		'type': 'string',&#10;		'value': ''&#10;	});&#10;&#10;	// Parameters&#10;	this.parameter('discoveryInterval', {&#10;		type: 'int',&#10;		value: 3500&#10;	});&#10;	this.parameter('listeningIpAddress', {&#10;		type: 'string',&#10;		value: '0.0.0.0'&#10;	});&#10;	this.parameter('listeningPort', {&#10;		type: 'int',&#10;		value: 50000&#10;	});&#10;	this.parameter('userName', {&#10;		type: 'string',&#10;		value: 'abcdefgh'&#10;	});&#10;};&#10;&#10;exports.initialize = function () {&#10;	var thiz = this;&#10;&#10;	// Initialize and set the socket	&#10;	closeAndOpenSocket.call(this);&#10;	running = true;&#10;	&#10;	// Trigger discovery &#10;	this.addInputHandler('triggerDiscovery', function() {&#10;		lifxLightBulb = null;&#10;		discoveredLifxLights = [];&#10;		discoveryMode = true;&#10;		&#10;		discoverLifx(socket);&#10;		&#10;		// Make sure to re-execute discovery if no bulb is already set&#10;		handleDiscovery = setInterval(function () {&#10;			if (thiz.lifxLightBulb) {&#10;				clearInterval(handleDiscovery);&#10;				discoveryMode = false;&#10;			} else {&#10;				// discoverLifx(socket);&#10;			}&#10;		}, this.getParameter('discoveryInterval'));&#10;	});&#10;	&#10;	// Select a discovered LifxLight, if applicable&#10;	this.addInputHandler('selectLight', function() {&#10;		var selectLight = this.get('selectLight');&#10;		if (discoveryMode) {&#10;			if (selectLight &lt; discoveredLifxLights.length) {&#10;				lifxLightBulb = discoveredLifxLights[selectLight];&#10;				console.log(&quot;selected light at &quot;+selectLight+&quot; with: &quot; + util.inspect(lifxLightBulb));&#10;				lifxLightBulb.switchOn(socket);&#10;				// FIXME: Should we empty the array of discovered lights?&#10;				discoveredLifxLights = [];&#10;				discoveryMode = false;&#10;			}&#10;		}&#10;	});&#10;	&#10;	// Manual bulb setup&#10;	this.addInputHandler('manualBulbSetup', function() {&#10;		discoveryMode = false;&#10;		discoveredLifxLights = [];&#10;		var bulb = this.get('manualBulbSetup');&#10;		lifxLightBulb = new LifxLight(bulb.ipAddress, bulb.port, bulb.macAddress, this.getParameter('userName'));&#10;	});&#10;&#10;	// Input handler for handling commands &#10;	this.addInputHandler('commands', function () {&#10;		if (lifxLightBulb) {&#10;			var commands = this.get('commands');&#10;			if (commands.on) {&#10;				lifxLightBulb.switchOn(socket);&#10;			&#10;				// Set color&#10;				if (commands.color) {&#10;					// ...&#10;				}&#10;				// ...&#10;			} else {&#10;				lifxLightBulb.switchOff(socket);&#10;			}&#10;		}&#10;	});&#10;};&#10;&#10;exports.wrapup = function () {&#10;	if (socket) {&#10;		socket.close();&#10;		socket = null;&#10;	}&#10;	lifxLightBulb = null;&#10;	running = false;&#10;	handleDiscovery = null;&#10;}&#10;&#10;/////////////////////////////////////////////////////////////////////////&#10;//// LifxLight class and its functions.&#10;&#10;/** Create using new a Lifx light bulb object. The created object includes the &#10; *  following properties:&#10; *  * **ipAddress**: The IP address of the bulb in the Local Area Network.&#10; *  * **port**: The port number. This usually defaults to 56700.&#10; *  * **macAddress**: The bulb's mac address.&#10; *  * **userName**: the userName, it is copied from the accessor parameter &#10; *      'userName' and checked to be 8 characters long.&#10; *  * **color**: The current light color&#10; *  * **power**: Boolean. Says if the light is on or off&#10; *&#10; *  @param ipAddress String with the ipAddress of the bulb&#10; *  @param port Bulb's communication port, it defaults to 56700&#10; *  @param macAddress A 12 bytes string of the mac address of the bulb.&#10; *  @param userName An 8 bytes string of the user name. If a wrong value is&#10; *   provided, then it is corrected.&#10; */&#10;function LifxLight (ipAddress, port, macAddress, userName) {&#10;    if (ipAddress &amp;&amp; typeof ipAddress === 'string') {&#10;        this.ipAddress = ipAddress;        &#10;    } else {&#10;        this.ipAddress = '';&#10;    }&#10;&#10;    if (port &amp;&amp; typeof port === 'number') {&#10;        this.port = Math.round(port);        &#10;    } else {&#10;        this.port = 56700;&#10;    }        &#10;&#10;    if (macAddress &amp;&amp; typeof macAddress === 'string') {&#10;        this.macAddress = macAddress;        &#10;    } else {&#10;        this.macAddress = '';&#10;    }&#10;    &#10;    // Force the userName to be 8 characters&#10;    if (userName &amp;&amp; typeof userName === 'string') {&#10;    	if (userName.lenght &gt; 8) {&#10;    		userName = userName.substring(0, 8);&#10;    	} else if (userName.lenght &lt; 8) {&#10;    		userName += 'abcdefgh';&#10;    		userName = userName.substring(0, 8);&#10;    	}&#10;    	this.userName = userName;&#10;    } else {&#10;    	this.userName = 'abcdefgh';&#10;    }&#10;&#10;    this.color = {};&#10;    this.power = false;&#10;}&#10;&#10;/** Switch the light on. First, the packet options are set. Then, the&#10; *  packet is build as a string of hexadecimal numbers. Finally, the packet&#10; *  is converted to a byte array format and sent via the socket.&#10; *&#10; *  @param socket The socket used for sending the udp message&#10; */&#10;LifxLight.prototype.switchOn = function(socket) {&#10;	var thiz = this;&#10;    // Set the options for switching the light on&#10;	console.log('this is switch on and the ip address is: '+this.ipAddress+'\n'+util.inspect(this));&#10;    var options = {};&#10;    options.size = '2a';&#10;    options.ackRequired = 1; options.resRequired = 1;&#10;    options.setPower = {}; options.setPower.on = true;&#10;&#10;    // Build the hexadecimal packet and then convert it to an array of bytes&#10;    var hexPacket = buildPacket.call(this, options);&#10;    console.log('prePacket = ' + hexPacket);&#10;    var packet = convertHexStringToByteArray(hexPacket);&#10;&#10;    // Send the packet over the provided socket&#10;    socket.send(packet, thiz.port, thiz.ipAddress, function () {&#10;        console.log('Switch light on ' + thiz.macAddress + '@' + thiz.ipAddress + ':' + thiz.port + ' msg = ' + packet);&#10;    });&#10;};&#10;&#10;/** Switch the light off. First, the packet options are set. Then, the&#10; *  packet is build as a string of hexadecimal numbers. Finally, the packet&#10; *  is converted to a byte array format and sent via the socket.&#10; *&#10; *  @param socket The socket used for sending the udp message&#10; */&#10;LifxLight.prototype.switchOff = function(socket) {&#10;    // Set the options for switching the light off&#10;    var options = {};&#10;    options.size = '2a';&#10;    options.ackRequired = 1; options.resRequired = 1;&#10;    options.setPower = {}; options.setPower.on = false;&#10;&#10;    // Build the hexadecimal packet and then convert it to an array of bytes&#10;    var hexPacket = buildPacket.call(this, options);&#10;    var packet = convertHexStringToByteArray(hexPacket);&#10;&#10;    // Send the packet over the provided socket&#10;    socket.send(packet, this.port, this.ipAddress, function () {&#10;        console.log('Switch light off ' + this.macAddress + ' at ' + this.ipAddress + ':' + this.port + ' msg = ' + message);&#10;    });&#10;};&#10;&#10;/** Set the Lifx light color. &#10; *  FIXME: What is the preferred color format to be supported?&#10; *&#10; *  @param socket The socket used for sending the udp message&#10; *  @param color&#10; */&#10;LifxLight.prototype.setColor = function(socket, color) {&#10;	// TODO&#10;}&#10;&#10;/////////////////////////////////////////////////////////////////////////&#10;//// Helper functions.&#10;&#10;/** &#10; * &#10; */&#10;var addToDiscovredLightsIfNew = function(packet) {&#10;	var isNew = true;&#10;	discoveredLifxLights.forEach(function(light) {&#10;		if (light.ipAddress === packet.ipAddress &amp;&amp; light.macAddress === packet.macAddress) {&#10;			isNew = false;&#10;			// TODO: Update the color and the power of the lifxLightBulb instance&#10;		}&#10;	});&#10;	if (isNew) {&#10;		discoveredLifxLights.push(new LifxLight(packet.ipAddress,&#10;				packet.port,&#10;				packet.macAddress,&#10;				this.getParameter('userName')));&#10;		return true;&#10;	}&#10;	return false;&#10;}&#10;&#10;/** Builds a UDP packet to be sent, based on the provided options.&#10; *  Please refer to https://lan.developer.lifx.com/docs/building-a-lifx-packet&#10; *  to know about the message format.&#10; *&#10; *  @param options A JSON object that describes the packet features&#10; *  @return UDP Packet to be sent &#10; */&#10;var buildPacket = function (options) {&#10;    var packet = '';&#10;&#10;    // ============================= Construct the header&#10;    // ----------------------- Frame&#10;    // -- size = 16bits&#10;    packet += options.size + '00';&#10;    // -- origin+tagged+addressable+protocol = 16bits&#10;    if (options.toAll) {&#10;        packet += '0034';&#10;    } else {&#10;        packet += '0014';&#10;    }&#10;    // -- source: set by the client (if all 0 then response broadcast) 32bits&#10;    packet += this.userName;&#10;&#10;    // ----------------------- Frame address&#10;    // -- target mac address (48bits)+0000&#10;    if (options.toAll) {&#10;        packet += '000000000000' +'0000';&#10;    } else {&#10;        packet += this.macAddress + '0000';        &#10;    }&#10;    // -- reserved (48bits)&#10;    packet += '000000000000';&#10;    // -- reserved + ack_required + res_required (8bits);&#10;    if (!options.ackRequired &amp;&amp; !options.resRequired) {&#10;        packet += '00';&#10;    } else if (!options.resRequired) {&#10;        packet += '02';&#10;    } else {&#10;        packet += '01';&#10;    };&#10;    // -- sequence (8bits): reference to the message&#10;    if (options.sequence) {&#10;        packet += ''+ options.sequence;&#10;    } else {&#10;        packet += '00';&#10;    }&#10;&#10;    // ----------------------- Protocol header&#10;    // -- reserved (64bits)&#10;    packet += '0000000000000000'; &#10;    // -- message type (16bits) + reserved (16bits)&#10;    if (options.get) {&#10;        packet += '6500' + '0000'; // Get --&gt; 101&#10;    } else if (options.setColor) { &#10;        packet += '6600' + '0000'; // SetColor --&gt; 102&#10;    } else         if (options.getPower) {&#10;        packet += '7400' + '0000'; // GetPower --&gt; 116&#10;    } else if (options.setPower) { &#10;        packet += '7500' + '0000'; // SetPower --&gt; 117&#10;    } else if (options.getInfrared) {&#10;        packet += '7800' + '0000'; // GetInfrared --&gt; 120&#10;    } else if (options.setInfrared) { &#10;        packet += '7a00' + '0000'; // SetInfrared --&gt; 122&#10;    }&#10;&#10;    // ============================= Construct the Payload&#10;    if (options.setPower) {&#10;        if (options.setPower.on) {&#10;            packet += 'ffff00000000';&#10;        } else {&#10;            packet += '000000000000';&#10;        }&#10;    }&#10;&#10;    if (options.setColor) {&#10;        // TODO&#10;    }&#10;&#10;    return packet;&#10;}&#10;&#10;/** &#10; * Creates and opens a socket&#10; */&#10;var closeAndOpenSocket = function () {&#10;	var thiz  = this;&#10;	var listeningPort = null;&#10;&#10;	if (socket) {&#10;		socket.on('close', function() {&#10;			socket = null;&#10;			closeAndOpenSocket.call(thiz);&#10;		});&#10;		socket.close();&#10;	} else {&#10;		var listeningPort = this.getParameter('listeningPort');&#10;		var listeningAddress = this.getParameter('listeningIpAddress');&#10;		var enableBroadcast = true;&#10;		&#10;		socket = udpSocket.createSocket(null, null, enableBroadcast);&#10;		    &#10;	    socket.setReceiveType('string');&#10;	    socket.setSendType('string');&#10;		socket.setRawBytes(true);&#10;	&#10;		socket.on('error', function (message) {&#10;	        error(message);&#10;	    });&#10;		socket.on('message', function (message, sender){&#10;		    if (running) {	        	&#10;		    	var packet = parseReceivedPacket(message, sender);&#10;		    	if (discoveryMode) {&#10;		    		// Check if this is a state message. Recall that a state message&#10;		    		// is sent after receiving a discovery message&#10;		    		if (packet.messageCode === '03') {&#10;		    			if (addToDiscovredLightsIfNew.call(thiz, packet)) {&#10;		    				var index = discoveredLifxLights.length - 1;&#10;		    				thiz.send('state', 'New discovered Lifx Light Bulb: ' + &#10;		    						packet.macAddress + '@' +  &#10;		    						packet.ipAddress + ':' + packet.port +&#10;		    						' added at index: ' + index);&#10;		    			}&#10;		    		}&#10;		    	} else {&#10;		    		if (lifxLightBulb.ipAddress === packet.ipAddress &amp;&amp;&#10;		    				lifxLightBulb.macAddress === packet.macAddress &amp;&amp;&#10;		    				lifxLightBulb.port === packet.port) {&#10;		    			switch (packet.messageCode) {&#10;		    			case '6b':&#10;		    				// The received message is a State message (code 107)&#10;		    				// lifxLightBulb.updateSate(packet.payload);&#10;		    				&#10;		    				break;&#10;		    			case '76':&#10;		    		        // The received message is a State Power message (code 118)&#10;		    				// lifxLightBulb.updateSate(packet.payload);&#10;		    				break;&#10;		    			case '79':&#10;		    		        // The received message is a StateInfrared message (code 121)&#10;		    				// lifxLightBulb.updateSate(packet.payload);&#10;		    				break;&#10;		    		    }&#10;		    		}&#10;		    		thiz.send('state', 'Message recived from: ' + packet.macAddress +&#10;		    				' * Message code is: ' + packet.messageCode);&#10;		    	}&#10;	        	&#10;		    }&#10;		});&#10;	    socket.on('listening', function () {&#10;	        if (running) {&#10;	        	console.log('listening: ' + true);&#10;	        }&#10;	    });&#10;	    socket.on('close', function () {&#10;	        if (running) {&#10;	            console.log('listening: ' + false);&#10;	        }&#10;	    });&#10;	&#10;	    try {&#10;	    	socket.bind(listeningPort, listeningAddress, function () {&#10;				console.log('bind success');&#10;			});&#10;	    } catch (e) {&#10;	    	this.setDefault('listeningPort', this.getParameter('listeningPort') + 1);&#10;	    	listeningPort = this.getParameter('listeningPort');&#10;	    	socket.bind(listeningPort, listeningAddress, function () {&#10;				console.log('bind success');&#10;			});&#10;	    }&#10;	}&#10;}&#10;&#10;/** Convenience function for converting a string, which each character is an&#10; *  hexadecimal number to an array buffer of bytes. This latter will contain &#10; *  unsigned bytes with the value of two consecutive characters from the provided&#10; *  string.&#10; *&#10; *  @param hexString String of hexadecimal values in each character&#10; *  @return converted hexString into ArrayBuffer&#10; */&#10;var convertHexStringToByteArray = function (hexString) {&#10;    var buffer = new ArrayBuffer();&#10;    var i = 0;&#10;    for (i = 0 ; i &lt; hexString.length ; i=i+2 ) {&#10;        var hs = hexString.slice(i, i+2);&#10;        buffer[ i / 2] = (parseInt(hs, 16)) &amp; 0xFF;&#10;    }&#10;    return buffer; &#10;}&#10;&#10;/** Broadcasts UPD discovery messages. If Lifx bubls are in the network, they will &#10; *  send back a State message.  &#10; * &#10; *  @param socket The socket instance to use for sending the discovery message&#10; */&#10;var discoverLifx = function (socket) {&#10;    // needs more elaboration&#10;    var hexPacket = '24000034abcdefgh00000000000000000000000000000003000000000000000002000000';&#10;    var packet = convertHexStringToByteArray(hexPacket);&#10;&#10;    // socket.setBroadcast(true);&#10;    socket.send(packet, 56700, '255.255.255.255', function (er) {&#10;        console.log('Start discovery: Broadcast at 255.255.255.255:56700... '+er);&#10;    });&#10;}&#10;&#10;/** Convenience function for converting a string str to another string hexString&#10; *  of hexadecimal characters. For this, each character of str is mapped into two&#10; *  characters that represent hexadecimal values.&#10; *&#10; *  @param bytesArray Array of raw bytes.&#10; *  @param start index from where to start the conversion.&#10; *  @param end index where to stop the conversion (index not included).&#10; *  @return converted bytes to a string of hexa values.&#10; */&#10;var getHexStringAt = function (bytesArray, start, end) {&#10;    var hexString = '', hex;&#10;    if (!end) {&#10;    	end = bytesArray.length;&#10;    }&#10;    for (var i = start ; i &lt; end ; i++ ) {&#10;        hex = bytesArray[i];&#10;        hex = (hex &amp; 0xFF).toString(16);&#10;        hexString += (&quot;000&quot;+hex).slice(-2);&#10;    }&#10;    return hexString; &#10;}&#10;&#10;/** Returns a JSON object that describes the received packet. This object contains:&#10; *  * ipAddress&#10; *&#10; *  @param messageBytes The received message during listening as a bytes array.&#10; *  @param sender String containing the IP Address and port of the message sender. &#10; *  @return JSON object describing the device and the message features.&#10; */&#10;var parseReceivedPacket = function (messageBytes, sender) {&#10;	var packetObject = {};&#10;	&#10;	// Extract packet information&#10;	packetObject.ipAddress = sender.substring(0, sender.indexOf(':'));&#10;	packetObject.port = Number(sender.substring(sender.indexOf(':') + 1));&#10;	packetObject.macAddress = getHexStringAt(messageBytes, 8, 14);&#10;	packetObject.messageCode = getHexStringAt(messageBytes, 32, 33);&#10;	&#10;	// TODO: add payload parsing, if applicable&#10;	// ...&#10;	&#10;    return packetObject;&#10;}&#10;&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/devices/Lifx.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="commands" class="ptolemy.actor.parameters.PortParameter" value="{}">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="manualBulbSetup" class="ptolemy.actor.parameters.PortParameter" value="{}">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="listeningIpAddress" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="userName" class="ptolemy.data.expr.Parameter" value="abcdefgh">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[260.0, 205.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor discovers and controls one of the available Lifx light bulbs &#10; in a local area network using Wifi. Configuration is not supported, and &#10; needs to be already done (using the app for example). In addition, the&#10; host need to be connected to the same LAN. &lt;/p&gt;&#10;&lt;p&gt; While it is possible to interact with Lifx bulbs over the Internet by &#10; sending HTTP requests to the Cloud account, this module does not provide&#10; such mechanism.&lt;/p&gt;&#10;&lt;p&gt; The communication with Lifx light bulbs is done over UDP/IP. Messages are &#10; arrays of numeric bytes ordered in little-endian. The packets construction&#10; can be found in this link:&#10; https://lan.developer.lifx.com/docs/introduction&lt;/p&gt;&#10;&lt;p&gt; Upon initialization, this accessor creates a UDP socket for communication.&#10; There are two ways to configure this accessor in order to control a bulb:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;the first one consists on discovering Lifx bulbs on the network and then &#10;selecting the one to use.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;the second is by running a manual setup, where the light parameters are&#10;received in the input port. A use case of this scenario is when a server &#10;sends information about available devices and their parameters.&lt;/p&gt;&#10;&lt;p&gt;Discovery starts if an input is provided in 'triggerDiscovery' input port. &#10;The accessor will broadcast discovery messages. Since available bulbs will &#10;be asynchronously sending State messages, the accessor will be listening.&#10;Discovery messages will repeatedly sent every 'discoveryInterval'&#10;parameter value, if no device has been selected. Each newly discovered &#10;light bulb will be added to discoveredLifxLights array. Selecting a device&lt;br&gt;is done by providing the index of the LifxLight in the array of discovered &#10;devices in the input port 'selectLight'.&lt;/p&gt;&#10;&lt;p&gt;Once the light bulb is configured, discovery will stop and the accessor will&#10;start to react to 'commands' input.&lt;/p&gt;&#10;&lt;p&gt;A LifxLight is a class that has the following parameters:&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;ipAddress&lt;/strong&gt;: IP address of the bulb in the LAN.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;port&lt;/strong&gt;: interger. It defaults to 56700 as noted in the Lifx developer&#10;  api.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;macAddress&lt;/strong&gt;: a string of 12 hex numbers (6bytes) that refer to the &#10;  bulb macAddress.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;color&lt;/strong&gt;: the current color.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;power&lt;/strong&gt;: if true, then the bulb is switched on, false if switched off.&#10;LifxLight declares a set of functions for control:&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;swithOn()&lt;/strong&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;swithOff()&lt;/strong&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;&lt;strong&gt;setColor()&lt;/strong&gt;&lt;/p&gt;&#10;&lt;p&gt;The &lt;em&gt;commands&lt;/em&gt; input is a JSON object that may have the following properties:&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;on: true to turn on; false to turn off.&lt;/li&gt;&#10;&lt;li&gt;bri: Brightness.  range 0 to 65535.&lt;/li&gt;&#10;&lt;li&gt;hue: Color, for bulbs that support color. This is a number in the&#10;range 0-65535.&lt;/li&gt;&#10;&lt;li&gt;sat: Saturation, for bulbs that support color. This is a number in the&#10;range 0-65535.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;temp: Temperature in Kelvin. Range 2500 (warm) to 9000 (cool)&lt;/p&gt;&#10;&lt;p&gt;HSBK is used to represent the color and color temperature of a light. The&#10;color is represented as an HSB (Hue, Saturation, Brightness) value.&#10;Please refer to https://en.wikipedia.org/wiki/HSL_and_HSV&lt;/p&gt;&#10;&lt;p&gt;In order to provide mechanisms for fault tolerance, all exchanged messages &#10;will request acknowledgment.&#10;TODO: Add mechanisms for detecting a fault occurrence&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Chadlia Jerad">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id: Lifx.js 1597 2017-04-29 15:41:50Z cxh $$">
            </property>
            <property name="listeningIpAddress (parameter)" class="ptolemy.kernel.util.StringAttribute" value="the IP address fo rthe accessor to listen to the&#10;  bulb packets. This defaults to 0.0.0.0 to listen to all UDP packets.">
            </property>
            <property name="listeningPort (parameter)" class="ptolemy.kernel.util.StringAttribute" value="the port number for listening. If a swarmlet is using two &#10;  or more instances of Lifx accessor, than each one needs to have its own distinct listening &#10;  port.">
            </property>
            <property name="state (port)" class="ptolemy.kernel.util.StringAttribute" value="outputs the received information from the bulb">
            </property>
            <property name="commands (port)" class="ptolemy.kernel.util.StringAttribute" value="JSON commands for the Hue, for example,&#10;               {&quot;on&quot; : false, &quot;hue&quot; : 120}">
            </property>
            <property name="ipAddress (parameter)" class="ptolemy.kernel.util.StringAttribute" value="the IP address of the bulb, returned by the discovery &#10;  mechanism">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="the port number for the communication with the bulb. This&#10;  parameter defaults to 56700, as specified by the Lifx API">
            </property>
            <property name="macAddress (parameter)" class="ptolemy.kernel.util.StringAttribute" value="the MAC address of the bulb, returned by the discovery &#10;  mechanism">
            </property>
        </property>
        <port name="commands" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="manualBulbSetup" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="triggerDiscovery" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="selectLight" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
        </port>
        <port name="state" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="SelectLight" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;exports.setup = function() {&#10;	this.output('index', {&#10;		'type': 'int',&#10;		'value': 0&#10;	});&#10;}&#10;&#10;exports.initialize = function() {&#10;	var thiz = this;&#10;	setTimeout(function() {&#10;		thiz.send('index', 0);&#10;	}, 1000);&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-150.0, 295.0]">
        </property>
        <port name="index" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="AlternateOnOff.generateCmd" relation="relation"/>
    <link port="TestSpontaneousOnce.output" relation="relation2"/>
    <link port="Display.input" relation="relation3"/>
    <link port="Lifx.commands" relation="relation"/>
    <link port="Lifx.triggerDiscovery" relation="relation2"/>
    <link port="Lifx.selectLight" relation="relation4"/>
    <link port="Lifx.state" relation="relation3"/>
    <link port="SelectLight.index" relation="relation4"/>
</entity>
