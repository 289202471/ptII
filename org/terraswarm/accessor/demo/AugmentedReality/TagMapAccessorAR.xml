<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="TagMapAccessorAR" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[55.0, 155.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={-27, 391, 1436, 729}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1202, 619]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="0.732930035249521">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{647.5395836830137, 459.5462433623788}">
    </property>
    <property name="_layoutConfiguration" class="ptolemy.vergil.basic.layout.ActorLayoutConfiguration">
        <property name="includeDecorations" class="ptolemy.data.expr.Parameter" value="false">
            <display name="Include decorations"/>
        </property>
        <property name="spacing" class="ptolemy.actor.parameters.DoubleRangeParameter" value="2.0">
            <display name="Object spacing"/>
        </property>
        <property name="logAspectRatio" class="ptolemy.actor.parameters.DoubleRangeParameter" value="-1.0">
            <display name="Aspect ratio"/>
        </property>
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This model looks for AR tags in an image, then using the ID of the AR tag, looks up an&#10;accessor, reifies it, and then overlays the sensor data provided by the accessor on the image.&#10;If the accessor provides a schema, then it will also construct a form for data entry to be sent&#10;back to the accessor.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[10.0, 365.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0,0.0,0.2,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="FIXME: As this display shows, the&#10;form data received via post is empty.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[765.0, 375.0]">
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="A variant of the augmented reality demo. All changes from the original are inside the TagToAccessorComposite.&#10;&#10;In the original, TagToAccessor knows upon initialization &#10;the mapping between april tag index and accessor. In the interest of making the demo more realistic,&#10;TagMapAccessorAR uses an accessor to get the mapping. For now there is just a dummy TagMap accessor, but in&#10;the future this could be replaced with a real accessor for a swarmbox which could return the mapping &#10;particular to the room where the swarmlet is run.&#10;&#10;Changes to the original demo are minor, but now the TagToAccessor must first wait for the IdToResource&#10;to be obtained from DummyTagMapAccessor before it can start sending accessors to the MutableAccessor.&#10;As a result, the new version fails to display data on the first actionable index obtained from IndexGenerator. It&#10;might be possible to 'fix' this problem by having the IndexGenerator wait another tick before sending&#10;an index, but once the dummy accessor is replaced by a real one we'd be in the same situation.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-5.0, 445.0]">
        </property>
    </property>
    <entity name="ObjectRecognizer" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/**&#10;Accessor to detect AprilTags in an image or stream of images.&#10;An AprilTag is a pattern of dark and light squares similar to a QR code but easier for&#10;cameras to detect robustly and at a distance.&#10;AprilTags were created by Associate Professor Edwin Olson (ebolson@umich.edu),&#10;EECS, University of Michigan. See [https://april.eecs.umich.edu/](https://april.eecs.umich.edu/#in_browser).&#10;&#10;The implementation of this accessor on the Ptolemy II/Nashorn accessor host&#10;uses an older Java implementation of the AprilTags detector written by Edwin Olson&#10;and more recently supplanted by a C version that performs much better. But this Java&#10;version is more easily included in Ptolemy II in a portable way. If you need better&#10;performance, consider replacing this with the C implementation and using JNI to interface&#10;to Ptolemy II.&#10;&#10;The input to this accessor is an image or a stream of images, e.g. from the Camera&#10;accessor.  There are two outputs. The one named _output_ is a modified version&#10;of the input image that outlines any detected AprilTags in the image&#10;and indicates their center and ID.  The _tags_ output is an array of&#10;objects representing the detected tags. Each object includes the following fields:&#10;&#10;+ _id_: The ID of the detected tag.&#10;+ _center_: An array with two doubles giving the center of the tag in pixel coordinates.&#10;+ _perimeter_: An array with four arrays, each of which gives the x and y coordinates of&#10;  a corner of the AprilTag.&#10;&#10;The AprilTags detector has a large number of parameters that can be tuned via&#10;the _options_ input. To set an option, provide a JSON object with a field matching&#10;the option name.  The options are described below using descriptions provided by&#10;by Edwin Olson in his Java implementation of an AprilTag detector:&#10;&#10;+ _MagThresh_: When growing components, the intra component variation is&#10;  allowed to grow when the component is small in size. This&#10;  threshold affects how much. The default is 1200.&#10;+ _MaxEdgeCost_: Set the maximum angle range allowed for the gradient directions&#10;  when connecting edges, in radians. This defaults to the radian&#10;  equivalent of 30 degrees.&#10;+ _MinMag_: Set the gradient magnitude threshold for ignoring pixels.&#10;  Do not consider pixels whose gradient magnitude is less than&#10;  minMag. Small values make the detector more sensitive, but also&#10;  force us to consider many more edges resulting in slower&#10;  computation time. A value of 0.001 is very sensitive. A value&#10;  of 0.01 is quite fast. The default is 0.004.&#10;+ _SegDecimate_: Set whether decimating before segmenting is enabled.&#10;  Instead of blurring the input image before segmentation, we&#10;  can achieve similar effects by decimating the image by a factor&#10;  of two. When enabled, this option applies a block LPF filter of&#10;  width 2, then decimates the image. With this option, not only&#10;  can we safely set segSigma = 0, but the slowest part of the&#10;  algorithm (the segmentation) runs about 4 times faster. The&#10;  downside is that the position of the targets is determined&#10;  based on the segmentation: lower resolution will result in more&#10;  localization error. However, the effect on quality is quite&#10;  modest, and this optimization is generally recommended (along&#10;  with segSigma = 0). If segSigma is non-zero, the filtering by&#10;  segSigma occurs first, followed by the block LPF, and the&#10;  decimation. This defaults to false, indicating that the option&#10;  is not enabled.&#10;+ _SegSigma_: Set the Gaussian smoothing kernel applied to image (0 == no filter)&#10;  used when detecting the outline of the box. It is almost always&#10;  useful to have some filtering, since the loss of small details&#10;  won't hurt. Recommended value = 0.8 (the default). The case where sigma ==&#10;  segsigma has been optimized to avoid a redundant filter&#10;  operation.&#10;+ _Sigma_: Set the Gaussian smoothing kernel applied to image (0 == no filter, the default)&#10;  used when sampling bits. Filtering is a good idea in cases&#10;  where A) a cheap camera is introducing artifical sharpening, B)&#10;  the bayer pattern is creating artifcats, C) the sensor is very&#10;  noisy and/or has hot/cold pixels. However, filtering makes it&#10;  harder to decode very small tags. Reasonable values are 0, or&#10;  [0.8, 1.5].&#10;+ _TagFamily_: Set the name of the tag family being detected.&#10;  This defaults to &quot;Tag36h11&quot;.&#10;  The supported families are &quot;Tag16h5&quot;, &quot;Tag25h7&quot;, &quot;Tag25h9&quot;, &quot;Tag36h10&quot;, and &quot;Tag36h11&quot;.&#10;  The default family seems least susceptible to false positives.&#10;+ _ThetaThresh_: When growing components, the intra component variation is&#10;  allowed to grow when the component is small in size. This&#10;  threshold affects how much. The default is 100.&#10;&#10;  @accessor image/AprilTags&#10;  @author Edward A. Lee (eal@eecs.berkeley.edu)&#10;  @input input An input image.&#10;  @output output An output image, with detected AprilTags outlined in green and identified.&#10;  @output tags An array of objects, one object for each tag detected in the image.&#10;  @parameter options The options for the detector. This is a JSON object with fields defined above.&#10;  It defaults to an empty object, meaning to use default values for all the otpions.&#10;  @version $$Id: AprilTags.js 1117 2016-11-23 00:59:47Z cxh $$&#10;*/&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals addInputHandler, exports, get, input, output, removeInputHandler, require, send,  */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var aprilTags = require('aprilTags');&#10;&#10;exports.setup = function () {&#10;    this.input('input');&#10;    this.output('output');&#10;    this.output('tags');&#10;    this.input('options', {&#10;        'type': 'JSON',&#10;        'value': ''&#10;    });&#10;};&#10;&#10;var handle;&#10;exports.initialize = function () {&#10;    handle = this.addInputHandler('input', function () {&#10;        var options = this.get('options');&#10;        var image = this.get('input');&#10;        var result = aprilTags.filter(image, options);&#10;        this.send('output', result);&#10;        var tags = aprilTags.tags();&#10;        if (tags) {&#10;            this.send('tags', tags);&#10;        }&#10;    });&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (handle) {&#10;        this.removeInputHandler(handle);&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/image/AprilTags.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor to detect AprilTags in an image or stream of images.&#10;An AprilTag is a pattern of dark and light squares similar to a QR code but easier for&#10;cameras to detect robustly and at a distance.&#10;AprilTags were created by Associate Professor Edwin Olson (ebolson@umich.edu),&#10;EECS, University of Michigan. See &lt;a href=&quot;https://april.eecs.umich.edu/#in_browser&quot;&gt;https://april.eecs.umich.edu/&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The implementation of this accessor on the Ptolemy II/Nashorn accessor host&#10;uses an older Java implementation of the AprilTags detector written by Edwin Olson&#10;and more recently supplanted by a C version that performs much better. But this Java&#10;version is more easily included in Ptolemy II in a portable way. If you need better&#10;performance, consider replacing this with the C implementation and using JNI to interface&#10;to Ptolemy II.&lt;/p&gt;&#10;&lt;p&gt;The input to this accessor is an image or a stream of images, e.g. from the Camera&#10;accessor.  There are two outputs. The one named &lt;em&gt;output&lt;/em&gt; is a modified version&#10;of the input image that outlines any detected AprilTags in the image&#10;and indicates their center and ID.  The &lt;em&gt;tags&lt;/em&gt; output is an array of&#10;objects representing the detected tags. Each object includes the following fields:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;em&gt;id&lt;/em&gt;: The ID of the detected tag.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;center&lt;/em&gt;: An array with two doubles giving the center of the tag in pixel coordinates.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;perimeter&lt;/em&gt;: An array with four arrays, each of which gives the x and y coordinates of&#10;a corner of the AprilTag.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;The AprilTags detector has a large number of parameters that can be tuned via&#10;the &lt;em&gt;options&lt;/em&gt; input. To set an option, provide a JSON object with a field matching&#10;the option name.  The options are described below using descriptions provided by&#10;by Edwin Olson in his Java implementation of an AprilTag detector:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;em&gt;MagThresh&lt;/em&gt;: When growing components, the intra component variation is&#10;allowed to grow when the component is small in size. This&#10;threshold affects how much. The default is 1200.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;MaxEdgeCost&lt;/em&gt;: Set the maximum angle range allowed for the gradient directions&#10;when connecting edges, in radians. This defaults to the radian&#10;equivalent of 30 degrees.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;MinMag&lt;/em&gt;: Set the gradient magnitude threshold for ignoring pixels.&#10;Do not consider pixels whose gradient magnitude is less than&#10;minMag. Small values make the detector more sensitive, but also&#10;force us to consider many more edges resulting in slower&#10;computation time. A value of 0.001 is very sensitive. A value&#10;of 0.01 is quite fast. The default is 0.004.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;SegDecimate&lt;/em&gt;: Set whether decimating before segmenting is enabled.&#10;Instead of blurring the input image before segmentation, we&#10;can achieve similar effects by decimating the image by a factor&#10;of two. When enabled, this option applies a block LPF filter of&#10;width 2, then decimates the image. With this option, not only&#10;can we safely set segSigma = 0, but the slowest part of the&#10;algorithm (the segmentation) runs about 4 times faster. The&#10;downside is that the position of the targets is determined&#10;based on the segmentation: lower resolution will result in more&#10;localization error. However, the effect on quality is quite&#10;modest, and this optimization is generally recommended (along&#10;with segSigma = 0). If segSigma is non-zero, the filtering by&#10;segSigma occurs first, followed by the block LPF, and the&#10;decimation. This defaults to false, indicating that the option&#10;is not enabled.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;SegSigma&lt;/em&gt;: Set the Gaussian smoothing kernel applied to image (0 == no filter)&#10;used when detecting the outline of the box. It is almost always&#10;useful to have some filtering, since the loss of small details&#10;won't hurt. Recommended value = 0.8 (the default). The case where sigma ==&#10;segsigma has been optimized to avoid a redundant filter&#10;operation.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;Sigma&lt;/em&gt;: Set the Gaussian smoothing kernel applied to image (0 == no filter, the default)&#10;used when sampling bits. Filtering is a good idea in cases&#10;where A) a cheap camera is introducing artifical sharpening, B)&#10;the bayer pattern is creating artifcats, C) the sensor is very&#10;noisy and/or has hot/cold pixels. However, filtering makes it&#10;harder to decode very small tags. Reasonable values are 0, or&#10;[0.8, 1.5].&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;TagFamily&lt;/em&gt;: Set the name of the tag family being detected.&#10;This defaults to &amp;quot;Tag36h11&amp;quot;.&#10;The supported families are &amp;quot;Tag16h5&amp;quot;, &amp;quot;Tag25h7&amp;quot;, &amp;quot;Tag25h9&amp;quot;, &amp;quot;Tag36h10&amp;quot;, and &amp;quot;Tag36h11&amp;quot;.&#10;The default family seems least susceptible to false positives.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;ThetaThresh&lt;/em&gt;: When growing components, the intra component variation is&#10;allowed to grow when the component is small in size. This&#10;threshold affects how much. The default is 100.&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id: AprilTags.js 1117 2016-11-23 00:59:47Z cxh $$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="An input image.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="An output image, with detected AprilTags outlined in green and identified.">
            </property>
            <property name="tags (port)" class="ptolemy.kernel.util.StringAttribute" value="An array of objects, one object for each tag detected in the image.">
            </property>
            <property name="options (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The options for the detector. This is a JSON object with fields defined above.&#10;  It defaults to an empty object, meaning to use default values for all the otpions.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="options" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{375.0, 225.0}">
        </property>
        <port name="options" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="tags" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ImageAnnotate" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** This accessor annotates an image provided at the _image_ input&#10; *  by rendering an SVG graphic overlaid on the image.&#10; *&#10; *  The _graphic_ input, if provided, gives an SVG specification of the graphic.&#10; *  Alternatively, if a _graphic_ input is not provided, or the _graphic_ input&#10; *  is empty, the _graphicURI_ input can provide a resource identifier for the graphic.&#10; *  This can be a URL or a local resource (a file) available on the host.&#10; *  Note that most hosts will restrict locations from which files can be read.&#10; *  Usually they will allow to read files in the directory where the swarmlet is located&#10; *  on the file system, or in a subdirectory of that directory.&#10; *  To read such a file, give a path relative to the location of the swarmlet.&#10; *&#10; *  The _translate_&#10; *  input can be used to shift the graphic in the X and Y directions,&#10; *  and the _rotate_ input can used to rotate the graphic.&#10; *&#10; *  The _options_ input can have the following fields:&#10; *  * __XOffset__: The horizontal offset for the graphic. If this is specified&#10; *    and a _translate_ input is also provided, the both offsets are applied.&#10; *  * __YOffset__: The vertical offset for the graphic. If this is specified&#10; *    and a _translate_ input is also provided, the both offsets are applied.&#10; *&#10; *  @accessor image/ImageAnnotate&#10; *  @input image The image to annotate.&#10; *  @input graphic The location of an SVG graphic to overlay on the image.&#10; *  @input translate An offset to apply to the graphic, as two element array specifying&#10; *   horizontal and vertical offsets in pixels.&#10; *  @input options A JSON object specifying options.&#10; *  @output output The filtered image.&#10; *  @author Edward A. Lee&#10; *  @version $$Id: ImageAnnotate.js 1117 2016-11-23 00:59:47Z cxh $$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals addInputHandler, exports, get, getResource, input, output, removeInputHandler, require, send */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var imageFilters = require('imageFilters');&#10;&#10;exports.setup = function () {&#10;    this.input('image');&#10;    this.input('graphic', {&#10;        'value': '',&#10;        'type': 'string'&#10;    });&#10;    this.input('graphicURI', {&#10;        'value': '',&#10;        'type': 'string'&#10;    });&#10;    this.input('scale', {&#10;        'value': 1.0,&#10;        'type': 'number'&#10;    });&#10;    this.input('rotation', {&#10;        'value': 0.0,&#10;        'type': 'number'&#10;    });&#10;    this.input('translate');&#10;    this.input('options', {&#10;        'value': '',&#10;        'type': 'JSON'&#10;    });&#10;    this.output('output');&#10;};&#10;&#10;exports.initialize = function () {&#10;    this.addInputHandler('image', function () {&#10;        var image = this.get('image');&#10;        var options = this.get('options');&#10;        if (!options) {&#10;            options = {};&#10;        }&#10;&#10;        var scale = this.get('scale');&#10;        if (scale !== null) {&#10;            // Combine with scale options, if specified.&#10;            if (options.Scale) {&#10;                scale *= options.Scale;&#10;            }&#10;            options.Scale = scale;&#10;        }&#10;&#10;        var rotation = this.get('rotation');&#10;        if (rotation !== null) {&#10;            // Combine with rotation options, if specified.&#10;            if (options.Rotation) {&#10;                rotation += options.Rotation;&#10;            }&#10;            options.Rotation = rotation;&#10;        }&#10;&#10;        var translate = this.get('translate');&#10;        if (translate !== null &amp;&amp; translate[0] !== null &amp;&amp; translate[1] !== null) {&#10;            // Combine with offset options, if specified.&#10;            var xOffset = translate[0];&#10;            if (options.XOffset) {&#10;                xOffset += options.XOffset;&#10;            }&#10;            options.XOffset = xOffset;&#10;&#10;            var yOffset = translate[1];&#10;            if (options.YOffset) {&#10;                yOffset += options.YOffset;&#10;            }&#10;            options.YOffset = yOffset;&#10;        }&#10;        var graphic = this.get('graphic');&#10;        if (graphic) {&#10;            options.Graphic = graphic;&#10;        } else {&#10;            var graphicURI = this.get('graphicURI');&#10;            if (graphicURI) {&#10;                // Second argument is a timeout.&#10;                options.Graphic = this.getResource(graphicURI, 3000);&#10;            }&#10;        }&#10;        var result = imageFilters.filter(image, 'Annotate', options);&#10;        this.send('output', result);&#10;    });&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/image/ImageAnnotate.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor annotates an image provided at the &lt;em&gt;image&lt;/em&gt; input&#10; by rendering an SVG graphic overlaid on the image.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;graphic&lt;/em&gt; input, if provided, gives an SVG specification of the graphic.&#10; Alternatively, if a &lt;em&gt;graphic&lt;/em&gt; input is not provided, or the &lt;em&gt;graphic&lt;/em&gt; input&#10; is empty, the &lt;em&gt;graphicURI&lt;/em&gt; input can provide a resource identifier for the graphic.&#10; This can be a URL or a local resource (a file) available on the host.&#10; Note that most hosts will restrict locations from which files can be read.&#10; Usually they will allow to read files in the directory where the swarmlet is located&#10; on the file system, or in a subdirectory of that directory.&#10; To read such a file, give a path relative to the location of the swarmlet.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;translate&lt;/em&gt;&#10; input can be used to shift the graphic in the X and Y directions,&#10; and the &lt;em&gt;rotate&lt;/em&gt; input can used to rotate the graphic.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;options&lt;/em&gt; input can have the following fields:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;XOffset&lt;/strong&gt;: The horizontal offset for the graphic. If this is specified&#10;and a &lt;em&gt;translate&lt;/em&gt; input is also provided, the both offsets are applied.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;YOffset&lt;/strong&gt;: The vertical offset for the graphic. If this is specified&#10;and a &lt;em&gt;translate&lt;/em&gt; input is also provided, the both offsets are applied.&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id: ImageAnnotate.js 1117 2016-11-23 00:59:47Z cxh $$">
            </property>
            <property name="image (port)" class="ptolemy.kernel.util.StringAttribute" value="The image to annotate.">
            </property>
            <property name="translate (port)" class="ptolemy.kernel.util.StringAttribute" value="An offset to apply to the graphic, as two element array specifying&#10;  horizontal and vertical offsets in pixels.">
            </property>
            <property name="options (port)" class="ptolemy.kernel.util.StringAttribute" value="A JSON object specifying options.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="The filtered image.">
            </property>
            <property name="graphic (port)" class="ptolemy.kernel.util.StringAttribute" value="The location of an SVG graphic to overlay on the image.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="options" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{1240.0, 210.0}">
        </property>
        <property name="graphic" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="30">
                </property>
            </property>
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="graphicURI" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="scale" class="ptolemy.actor.parameters.PortParameter" value="1">
        </property>
        <property name="rotation" class="ptolemy.actor.parameters.PortParameter" value="0">
        </property>
        <port name="options" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="graphic" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="graphicURI" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="scale" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="rotation" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="image" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="translate" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ImageReader" class="ptolemy.actor.lib.image.ImageReader">
        <property name="fileOrURL" class="ptolemy.data.expr.FileParameter" value="MechanicalRoom.jpg">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{215.0, 235.0}">
        </property>
    </entity>
    <entity name="GraphicOverlay" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.input('reset');&#10;	this.input('translation');&#10;	this.input('json');&#10;	this.output('svg', {'type':'string'});&#10;	this.output('latestTranslation');&#10;	this.parameter('padding', {'type':'number', 'value':10});&#10;	this.parameter('rowPadding', {'type':'number', 'value':5});&#10;	// Font size in pixels.&#10;	this.parameter('fontSize', {'type':'number', 'value':20});&#10;	// Average character width (hint for box width)&#10;	this.parameter('averageCharacterWidth', {'type':'number', 'value':0.75});&#10;}&#10;exports.initialize = function() {&#10;	var thiz = this;&#10;	&#10;	var fontSize = this.get('fontSize');&#10;	// Hack to estimate the width of text to make the box:&#10;	var averageCharacterWidth = this.get('averageCharacterWidth');&#10;	var padding = this.getParameter('padding');&#10;	var rowPadding = this.getParameter('rowPadding');&#10;	// Default graphic.&#10;	var noData = '&lt;svg&gt;'&#10;		+ '&lt;rect style=&quot;fill:white;stroke:red;stroke-width:2;opacity:0.7&quot; width=&quot;'&#10;		+ (7*fontSize*averageCharacterWidth)&#10;		+ '&quot; height=&quot;'&#10;		+ (fontSize + 2*padding)&#10;		+ '&quot;/&gt;'&#10;		+ '&lt;text x=&quot;'&#10;		+ padding&#10;		+ '&quot; y=&quot;'&#10;		+ (padding + fontSize)&#10;		+ '&quot; style=&quot;font-size:'&#10;		+ fontSize &#10;		+ 'px&quot;&gt;No data&lt;/text&gt;'&#10;		+ '&lt;/svg&gt;';&#10;	var graphic = noData;&#10;	&#10;	this.addInputHandler('reset', function() {&#10;		if (thiz.get('reset')) {&#10;			graphic = noData;&#10;		}&#10;	});&#10;	this.addInputHandler('json', function() {&#10;		var json = thiz.get('json');&#10;		try {&#10;			json = JSON.parse(json);&#10;		} catch(err) {&#10;			json = {'error': err.message};&#10;		}&#10;		if (!json || Object.keys(json).length === 0) {&#10;			graphic = noData;&#10;			return;&#10;		}&#10;		var nameColumn = '';&#10;		var valueColumn = '';&#10;		var y = padding + fontSize;&#10;		var nameColumnWidth = 0;&#10;		for (property in json) {&#10;			nameColumn += '&lt;tspan x=&quot;'&#10;					+ padding&#10;					+ '&quot; y=&quot;'&#10;					+ y&#10;					+ '&quot;&gt;'&#10;					+ property&#10;					+ '&lt;/tspan&gt;';&#10;			y += (rowPadding + fontSize);&#10;			if (nameColumnWidth &lt; property.length) {&#10;				nameColumnWidth = property.length;&#10;			}&#10;		}&#10;		y = padding + fontSize;&#10;		var valueColumnWidth = 0;&#10;		var x = (padding + nameColumnWidth * fontSize * averageCharacterWidth);&#10;		for (property in json) {&#10;			value = util.inspect(json[property]);&#10;			valueColumn += '&lt;tspan x=&quot;'&#10;					+ x&#10;					+ '&quot; y=&quot;'&#10;					+ y&#10;					+ '&quot;&gt;'&#10;					+ value&#10;					+ '&lt;/tspan&gt;';&#10;			y += (rowPadding + fontSize);&#10;			if (valueColumnWidth &lt; value.length) {&#10;				valueColumnWidth = value.length;&#10;			}&#10;		};&#10;		var height = y;&#10;		var width = (nameColumnWidth + valueColumnWidth) &#10;				* fontSize * averageCharacterWidth&#10;				+ (2 * padding);&#10;		graphic = '&lt;svg width=&quot;'  // Opening svg tag.&#10;				+ width&#10;				+ '&quot; height=&quot;'&#10;				+ height&#10;				+ '&quot;&gt;'&#10;				+ '&lt;rect width=&quot;' // Background rectangle.&#10;				+ width&#10;				+ '&quot; height=&quot;'&#10;				+ height&#10;				+ '&quot; style=&quot;fill:white;stroke:red;stroke-width:2;opacity:0.7&quot;'&#10;				+ '&gt;&lt;/rect&gt;'&#10;				+ '&lt;text style=&quot;font-size:'   // Name column.&#10;				+ fontSize &#10;				+ 'px&quot; x=&quot;'     &#10;				+ padding&#10;				+ '&quot; y=&quot;'&#10;				+ padding&#10;				+ '&quot;&gt;'&#10;				+ nameColumn&#10;				+ '&lt;/text&gt;'&#10;				+ '&lt;text style=&quot;font-size:'   // Value column.&#10;				+ fontSize &#10;				+ 'px&quot; x=&quot;'     &#10;				+ padding&#10;				+ '&quot; y=&quot;'&#10;				+ (padding + fontSize)&#10;				+ '&quot;&gt;'&#10;				+ valueColumn&#10;				+ '&lt;/text&gt;'&#10;				+ '&lt;/svg&gt;';       // Closing.&#10;	});&#10;	this.addInputHandler('translation', function() {&#10;		var translation = thiz.get('translation');&#10;		thiz.send('latestTranslation',translation);&#10;		thiz.send('svg', graphic);&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{1045.0, 200.0}">
        </property>
        <port name="svg" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="latestTranslation" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="reset" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="translation" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="json" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="TestSpontaneous" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Test accessor that spontaneously produces outputs once per time interval.&#10;//&#10;// Copyright (c) 2015-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Test accessor that spontaneously produces outputs once per time interval.&#10; *  This implementation produces a counting sequence.&#10; *&#10; *  @accessor test/TestSpontaneous&#10; *  @parameter interval The interval between outputs in milliseconds.&#10; *  @output output Output for the counting sequence, of type number.&#10; *  @author Edward A. Lee&#10; *  @version $$Id: TestSpontaneous.js 1117 2016-11-23 00:59:47Z cxh $$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals clearInterval, exports, require, setInterval */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;exports.setup = function () {&#10;    this.parameter('interval', {&#10;        'type': 'number',&#10;        'value': 1000&#10;    });&#10;    this.output('output', {&#10;        'type': 'number'&#10;    });&#10;};&#10;&#10;// These variables will not be visible to subclasses.&#10;var handle = null;&#10;var count = 0;&#10;&#10;exports.initialize = function () {&#10;    count = 0;&#10;    // Need to record 'this' for use in the callback.&#10;    var thiz = this;&#10;    handle = setInterval(function () {&#10;        thiz.send('output', count);&#10;        count += 1;&#10;    }, this.getParameter('interval'));&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (handle) {&#10;        clearInterval(handle);&#10;        handle = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/test/TestSpontaneous.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Test accessor that spontaneously produces outputs once per time interval.&#10; This implementation produces a counting sequence.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id: TestSpontaneous.js 1117 2016-11-23 00:59:47Z cxh $$">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="Output for the counting sequence, of type number.">
            </property>
            <property name="interval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The interval between outputs in milliseconds.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{20.0, 290.0}">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="MutableAccessor" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// This script defines a MutableAccessor that can be reified&#10;// by accessors having a control input and data and schema outputs.&#10;&#10;exports.setup = function() {&#10;	// First, set that this is a mutable accessor that&#10;	// realizes 'controling' functionality&#10;	this.mutable(true);	&#10;	this.realize('controllableSensor');&#10;&#10;	// Defining inputs&#10;	// the MutableAccessor will receive in this input the acessor code&#10;	this.input('accessor', {&#10;		'type': 'string',&#10;		'value': ''&#10;	});&#10;	// This input can be used by the reified accessor&#10;	this.input('control', {&#10;		'type': 'JSON',&#10;	});&#10;&#10;	// Defining outputs&#10;	this.output('data', { 'spontaneous':true,&#10;		'type': 'JSON',&#10;		'value': null		&#10;	});&#10;	this.output('schema', { 'spontaneous':true,&#10;		'type': 'JSON',&#10;		'value': null&#10;	});&#10;};&#10;&#10;exports.initialize = function() {&#10;	var thiz = this;&#10;&#10;	this.addInputHandler('accessor', function() {&#10;		var accessorCode = this.get('accessor');&#10;		if (accessorCode &amp;&amp; accessorCode.length &gt; 0) {&#10;			try {&#10;				var accessor = this.instantiateFromCode('aa', accessorCode);&#10;			&#10;				accessor.container = null;&#10;				thiz.containedAccessors.splice(thiz.containedAccessors.indexOf(accessor), 1);&#10;				&#10;				// Reification test&#10;				if (thiz.reifiableBy(accessor)) {&#10;					// If the new accessor is reifiable, then remove &#10;					// the previous reification , if any&#10;					if (thiz.status === 'reified') {&#10;						// console.log('removing reification');&#10;						thiz.removeReification();&#10;						// Send null to indicate that the new reification&#10;						// has not produced any data.&#10;						thiz.send('data', null);&#10;					};&#10;					// thiz.send('data' , {'AccName': accessor.accessorName});&#10;					// Then reify the new one&#10;					thiz.reify(accessor);&#10;					accessor.initialize();&#10;				};&#10;			} catch (e) {&#10;				thiz.send('data', null);&#10;			}&#10;		}&#10;	});&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{870.0, 255.0}">
        </property>
        <property name="accessor" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="control" class="ptolemy.actor.parameters.PortParameter" value="0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="accessor" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="control" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="data" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="schema" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="IndexGenerator" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Upon receiving the first non-empty array of tags at the input, this script&#10;// outputs a 0 to specify to use the first tag. After it has received&#10;// holdCount more inputs, it outputs a 1 to select the second tag, if there&#10;// is one. It continues like this cycling back to 0 whenever there are not&#10;// enough tags to select the next index.  This also outputs true on the&#10;// reset output each time the index changes or if there are no tags.&#10;&#10;exports.setup = function() {&#10;	this.input('tags');&#10;	this.output('reset', {&#10;		'type': 'boolean'&#10;	});&#10;	this.output('index', {&#10;		'type': 'int'&#10;	});&#10;	this.parameter('holdCount', {&#10;		'type': 'int',&#10;		'value': 10&#10;	});&#10;}&#10;&#10;exports.initialize = function() {&#10;	var thiz = this;&#10;	&#10;	var first = true;&#10;	var index = 0;&#10;	var count = 0;&#10;	var holdCount = thiz.get('holdCount');&#10;	&#10;	this.addInputHandler('tags', function() {&#10;		var tags = thiz.get('tags');&#10;		if (first &amp;&amp; tags &amp;&amp; tags.length &gt; 0) {&#10;			thiz.send('index', index);&#10;			first = false;&#10;			thiz.send('reset', true);&#10;			return;&#10;		}&#10;		count++;&#10;		if (count &gt;= holdCount) {&#10;			count = 0;&#10;			// Only switch if there is more than one tag.&#10;			if (tags &amp;&amp; tags.length &gt; 1) {&#10;				index++;&#10;				if (index &gt;= tags.length) {&#10;					index = 0;&#10;				}&#10;				thiz.send('index', index);&#10;				thiz.send('reset', true);&#10;			}&#10;		}&#10;		if (!tags) {&#10;			thiz.send('reset', true);&#10;		}&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{550.0, 175.0}">
        </property>
        <property name="holdCount" class="ptolemy.data.expr.Parameter" value="10">
        </property>
        <port name="tags" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="reset" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="index" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Browser" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Accessor that connects with a browser on the local host.&#10;//&#10;// Copyright (c) 2016-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Accessor that connects with a browser on the local host.&#10; *  This is intended to be used by a swarmlet to interact with users,&#10; *  for example by displaying content and providing forms to be filled in.&#10; *  Initial content on the page may be specified using the *content*&#10; *  parameter and HTML header content may be specified using *header*.&#10; *  &#10; *  Whatever text is received on the *html* input port will replace the content&#10; *  of the web page. Normally, this will be HTML text without any DOCTYPE or&#10; *  header and without a body tag. Each time new text is received, the content&#10; *  of the page will be updated.&#10; *  &#10; *  The page will be opened upon initialize if *content* is not empty.&#10; *  Otherwise, it will be opened when the first *html* input is received.&#10; *  &#10; *  The *resources* input can be used to provide resources, such as images,&#10; *  that will be used by the HTML content provided on the *html* input.&#10; *  Note that updating a resource with the same name will not normally result&#10; *  in the web page being updated because browsers normally cache such resources.&#10; *  If HTML content refers to a resource that has already been loaded (or more&#10; *  precisely, that has the same name as a resource that has already been loaded),&#10; *  then the browser will not load the resource again, but rather will use the&#10; *  previous version.  You can force the browser to reload a resource by augmenting&#10; *  the name with parameters (which will be ignored). For example, if you have&#10; *  a resource named &quot;image.jpg&quot; that you wish to update it, then you can&#10; *  specify HTML like this:&#10; *  &#10; *     &amp;lt;img src=&quot;image.jpg?count=n&quot;/&amp;gt;&#10; *  &#10; *  where *n* is a unique integer not previously seen by the browser.&#10; *  This will force the browser to go back to the server to retrieve the resource.&#10; *&#10; *  The way this accessor works on most hosts is that it starts a web server on localhost&#10; *  at the specified port that serves the specified web page and then instructs&#10; *  the system default browser to load the default page from that server.&#10; *  The page served by the server includes a script that listens for websocket&#10; *  connections that are used to provide HTML content to display on the page.&#10; *  Some hosts, however, such as the cordova and browser hosts, natively use&#10; *  a browser as part of the host, so in these cases, no web server nor socket&#10; *  connection is needed and the *port* parameter will be ignored.&#10; *  &#10; *  @accessor utilities/Browser&#10; *  @input {string} html HTML content to render in the body of the page displayed&#10; *   by the browser.&#10; *  @input resources An object where each named property is an object containing&#10; *   two properties, 'data' and 'contentType'. The name of the named property is&#10; *   the path to be used to access the resource. The 'data' property is the resource&#10; *   itself, an arbitrary collection of bytes. The 'contentType' is the MIME&#10; *   type of the data.&#10; *  @parameter {string} header HTML content to include in the header part of the web page.&#10; *   This is a good place to script definitions.&#10; *  @parameter {string} content HTML content to include in the main body of the page.&#10; *   If this is non-empty, then the page is opened upon initialize.&#10; *   Otherwise, the page is opened when the first *html* input is received.&#10; *  @parameter {int} port The port to use, if needed, for websocket communication between this&#10; *   accessor (which updates the HTML content of the web page) and the browser.&#10; *   The web page will listen on this socket for content and display whatever arrives&#10; *   on that port. This is ignored on hosts that do not need to invoke an external browser.&#10; *  @author Edward A. Lee (eal@eecs.berkeley.edu)&#10; *  @version $$Id: Browser.js 1923 2017-07-04 18:32:20Z eal $$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should be no&#10;// space between the / and the * and global. See https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*global  exports, require */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var Browser = require('browser');&#10;var browser = null;&#10;&#10;exports.setup = function () {&#10;    this.parameter('header', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;    this.parameter('content', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;    this.input('html', {&#10;        'type': 'string'&#10;    });&#10;    this.input('resources');&#10;    this.output('post', {&#10;        'type': 'JSON'&#10;    });&#10;    this.parameter('port', {&#10;        'type': 'int',&#10;        'value': 8080&#10;    });&#10;};&#10;&#10;var display = function () {&#10;    // Check for any new resources.&#10;    var resources = this.get('resources');&#10;    if (resources) {&#10;        for (var name in resources) {&#10;            browser.addResource(name, resources[name].data, resources[name].contentType);&#10;        }&#10;    }&#10;&#10;    var toDisplay = this.get('html');&#10;    browser.display(toDisplay);&#10;};&#10;&#10;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    &#10;    browser = new Browser.Browser(&#10;            {'port': self.getParameter('port')},&#10;            self.getParameter('header'),&#10;            self.getParameter('content')&#10;    );&#10;    // Listen for any POST to the server.&#10;    browser.addListener('/', function(data) {&#10;        self.send('post', JSON.parse(data));&#10;    });&#10;&#10;    this.addInputHandler('html', display.bind(this));&#10;&#10;    this.addInputHandler('resources', function() {&#10;        var resources = this.get('resources');&#10;        for (var name in resources) {&#10;            browser.addResource(name, resources[name].data, resources[name].contentType);&#10;        }&#10;    });&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (browser) {&#10;        browser.stop();&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/Browser.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor that connects with a browser on the local host.&#10; This is intended to be used by a swarmlet to interact with users,&#10; for example by displaying content and providing forms to be filled in.&#10; Initial content on the page may be specified using the &lt;em&gt;content&lt;/em&gt;&#10; parameter and HTML header content may be specified using &lt;em&gt;header&lt;/em&gt;.&lt;/p&gt;&#10;&lt;p&gt; Whatever text is received on the &lt;em&gt;html&lt;/em&gt; input port will replace the content&#10; of the web page. Normally, this will be HTML text without any DOCTYPE or&#10; header and without a body tag. Each time new text is received, the content&#10; of the page will be updated.&lt;/p&gt;&#10;&lt;p&gt; The page will be opened upon initialize if &lt;em&gt;content&lt;/em&gt; is not empty.&#10; Otherwise, it will be opened when the first &lt;em&gt;html&lt;/em&gt; input is received.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;resources&lt;/em&gt; input can be used to provide resources, such as images,&#10; that will be used by the HTML content provided on the &lt;em&gt;html&lt;/em&gt; input.&#10; Note that updating a resource with the same name will not normally result&#10; in the web page being updated because browsers normally cache such resources.&#10; If HTML content refers to a resource that has already been loaded (or more&#10; precisely, that has the same name as a resource that has already been loaded),&#10; then the browser will not load the resource again, but rather will use the&#10; previous version.  You can force the browser to reload a resource by augmenting&#10; the name with parameters (which will be ignored). For example, if you have&#10; a resource named &amp;quot;image.jpg&amp;quot; that you wish to update it, then you can&#10; specify HTML like this:&lt;/p&gt;&#10;&lt;pre class=&quot;prettyprint source&quot;&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;image.jpg?count=n&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; where &lt;em&gt;n&lt;/em&gt; is a unique integer not previously seen by the browser.&#10; This will force the browser to go back to the server to retrieve the resource.&lt;/p&gt;&#10;&lt;p&gt; The way this accessor works on most hosts is that it starts a web server on localhost&#10; at the specified port that serves the specified web page and then instructs&#10; the system default browser to load the default page from that server.&#10; The page served by the server includes a script that listens for websocket&#10; connections that are used to provide HTML content to display on the page.&#10; Some hosts, however, such as the cordova and browser hosts, natively use&#10; a browser as part of the host, so in these cases, no web server nor socket&#10; connection is needed and the &lt;em&gt;port&lt;/em&gt; parameter will be ignored.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id: Browser.js 1928 2017-07-12 19:44:57Z eal $$">
            </property>
            <property name="html (port)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to render in the body of the page displayed&#10;  by the browser.">
            </property>
            <property name="resources (port)" class="ptolemy.kernel.util.StringAttribute" value="An object where each named property is an object containing&#10;  two properties, 'data' and 'contentType'. The name of the named property is&#10;  the path to be used to access the resource. The 'data' property is the resource&#10;  itself, an arbitrary collection of bytes. The 'contentType' is the MIME&#10;  type of the data.">
            </property>
            <property name="header (parameter)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to include in the header part of the web page.&#10;  This is a good place to script definitions.">
            </property>
            <property name="content (parameter)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to include in the main body of the page.&#10;  If this is non-empty, then the page is opened upon initialize.&#10;  Otherwise, the page is opened when the first *html* input is received.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to use, if needed, for websocket communication between this&#10;  accessor (which updates the HTML content of the web page) and the browser.&#10;  The web page will listen on this socket for content and display whatever arrives&#10;  on that port. This is ignored on hosts that do not need to invoke an external browser.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{1545.0, 255.0}">
        </property>
        <property name="header" class="ptolemy.data.expr.Parameter" value="&lt;title&gt;AugmentedReality Demo&lt;/title&gt;&#10;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/brutusin.json-forms/1.3.2/css/brutusin-json-forms.min.css&quot;/&gt;&#10;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;/&gt;&#10;&lt;script src=&quot;https://code.jquery.com/jquery-1.12.2.min.js&quot;&gt;&lt;/script&gt;&#10;&lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/brutusin.json-forms/1.3.2/js/brutusin-json-forms.min.js&quot;&gt;&lt;/script&gt;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/brutusin.json-forms/1.3.2/js/brutusin-json-forms-bootstrap.min.js&quot;&gt;&lt;/script&gt;">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="30">
                </property>
            </property>
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="content" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="html" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="resources" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="post" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
    </entity>
    <entity name="Display" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={189, 649, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{1670.0, 315.0}">
        </property>
    </entity>
    <entity name="JavaScript2" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// First attempt based on: https://stackoverflow.com/questions/12905849/generating-html-forms-from-json-or-xml-feed-using-jquery&#10;// A proper Form generator will require a DOM parser to insert things into an existing HTML source. This is just a one-off accessor.&#10;&#10;exports.setup = function() {&#10;	this.input('image');&#10;	this.input('spec', {'type':'JSON'});&#10;	this.output('html', {'type':'string'});&#10;	this.output('resources');&#10;}&#10;exports.initialize = function() {&#10;	var thiz = this;&#10;	&#10;	var htmlSent = false;&#10;	var spec = null;&#10;	&#10;	this.addInputHandler('spec', function() {&#10;		var newSpec = JSON.stringify(thiz.get('spec'));&#10;		if (newSpec != spec) {&#10;			// Force a new web page if a new form has to be generated.&#10;			htmlSent = false;&#10;			spec = newSpec;&#10;		}&#10;	});&#10;	this.addInputHandler('image', function() {&#10;		var image = this.get('image');&#10;		this.send('resources', {&#10;			'image.jpg': {&#10;				'data': image,&#10;				'contentType': 'image/jpeg'&#10;			}&#10;		});&#10;		var html = '&lt;h1&gt;Augmented Reality Demo&lt;/h1&gt;\n';&#10;		&#10;		if (spec) {&#10;		html += '\&#10;		&lt;script type=&quot;text/javascript&quot;&gt; \n\&#10;		var BrutusinForms = brutusin[&quot;json-forms&quot;]; \n \&#10;		var bf = null; \n \&#10;		function submit() { \n \&#10;	      bf.validate(); \n \&#10;	      alert(JSON.stringify(bf.getData())); \n \&#10;	      $.post( &quot;/&quot;, bf.getData()); \n \&#10;	    } \n \&#10;		bf = BrutusinForms.create( \n';&#10;		html += spec;&#10;		html += '); \n\&#10;	    var container = document.getElementById(&quot;container&quot;); \n\&#10;	    bf.render(container); \n\&#10;	  &lt;/script&gt; \n';&#10;		}&#10;		// For the image, we use a timed update to avoid the web page&#10;		// flashing on reloading the whole thing.  The ?count=number&#10;		// appended to the image file name forces the browser to reload&#10;		// the image, but the server ignores this additional information&#10;		// and just serves the latest version of the image.&#10;		html += '&lt;img src=&quot;image.jpg&quot; id=&quot;image&quot; width=&quot;600&quot;/&gt;\n \&#10;      &lt;script&gt;var count = 0;\n \&#10;      setInterval(function() {\n \&#10;         var e = document.getElementById(&quot;image&quot;);\n \&#10;         e.src = &quot;image.jpg?count=&quot; + (count++);\n \&#10;      }, 1000);\n \&#10;      &lt;/script&gt;\n';&#10;      if (spec) {&#10;      	html += '\&#10;      &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; \n\&#10;      &lt;button class=&quot;btn btn-primary&quot; onclick=&quot;submit()&quot;&gt;Submit&lt;/button&gt;\n';&#10;		}&#10;		if (!htmlSent) {&#10;			thiz.send('html', html);&#10;			htmlSent = true;&#10;		}&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{1385.0, 255.0}">
        </property>
        <port name="image" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="spec" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="html" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="resources" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TagToAccessorComposite" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function(){&#10;	&#10;	//Inputs&#10;	this.input('trigger');&#10;	this.input('tags');&#10;    this.input('index', {&#10;    	'type':'int', &#10;        'value':0&#10;    });&#10;    &#10;    //Outputs&#10;    this.output('translation');&#10;    this.output('accessor', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;    &#10;    //Accessors&#10;    var DummyTagMapAccessorCode = getResource('VariantAccessors/DummyTagMapAccessor.js', 2000);&#10;    var DummyTagMapAccessor = this.instantiateFromCode('DummyTagMapAccessor', DummyTagMapAccessorCode);&#10;    &#10;    var TagToAccessorVariant1Code = getResource('VariantAccessors/TagToAccessorVariant1.js', 2000);&#10;    var TagToAccessorVariant1 = this.instantiateFromCode('TagToAccessorVariant1', TagToAccessorVariant1Code);&#10;&#10;	//Connections&#10;	this.connect('trigger', DummyTagMapAccessor, 'trigger');&#10;	&#10;	this.connect('tags', TagToAccessorVariant1, 'tags');&#10;	this.connect('index', TagToAccessorVariant1, 'index');&#10;	&#10;	this.connect(DummyTagMapAccessor, 'IdToResource', TagToAccessorVariant1, 'IdToResource');&#10;	&#10;	this.connect(TagToAccessorVariant1, 'translation', 'translation');&#10;	this.connect(TagToAccessorVariant1, 'accessor', 'accessor');&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{710.0, 235.0}">
        </property>
        <property name="index" class="ptolemy.actor.parameters.PortParameter" value="0">
        </property>
        <port name="index" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="tags" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="translation" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="accessor" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;ImageAnnotate.translate&quot;,x=1240.0,y=210.0}, tail={id=&quot;GraphicOverlay.latestTranslation&quot;,x=1045.0,y=200.0}, points={1150.0,240.0,1150.0,210.0} } }">
        </property>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;ImageAnnotate.graphic&quot;,x=1240.0,y=210.0}, tail={id=&quot;GraphicOverlay.svg&quot;,x=1045.0,y=200.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation11" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="{1615.0, 315.0}">
        </vertex>
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;MutableAccessor.control&quot;,x=870.0,y=255.0}, tail={id=&quot;relation11.vertex1&quot;,x=1615.0,y=315.0}, points={795.0,265.0,795.0,315.0} },{ head={id=&quot;Display.input&quot;,x=1670.0,y=315.0}, tail={id=&quot;relation11.vertex1&quot;,x=1615.0,y=315.0}, points={} },{ head={id=&quot;Browser.post&quot;,x=1545.0,y=255.0}, tail={id=&quot;relation11.vertex1&quot;,x=1615.0,y=315.0}, points={1605.0,255.0,1605.0,315.0} } }">
        </property>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="{490.0, 235.0}">
        </vertex>
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;IndexGenerator.tags&quot;,x=550.0,y=175.0}, tail={id=&quot;relation3.vertex1&quot;,x=490.0,y=235.0}, points={490.0,175.0} },{ head={id=&quot;ObjectRecognizer.tags&quot;,x=375.0,y=225.0}, tail={id=&quot;relation3.vertex1&quot;,x=490.0,y=235.0}, points={} },{ head={id=&quot;TagToAccessorComposite.tags&quot;,x=710.0,y=235.0}, tail={id=&quot;relation3.vertex1&quot;,x=490.0,y=235.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;GraphicOverlay.json&quot;,x=1045.0,y=200.0}, tail={id=&quot;MutableAccessor.data&quot;,x=870.0,y=255.0}, points={965.0,210.0,965.0,245.0} } }">
        </property>
    </relation>
    <relation name="relation16" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="{135.0, 290.0}">
        </vertex>
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;TestSpontaneous.output&quot;,x=20.0,y=290.0}, tail={id=&quot;relation16.vertex1&quot;,x=135.0,y=290.0}, points={} },{ head={id=&quot;ImageReader.trigger&quot;,x=215.0,y=235.0}, tail={id=&quot;relation16.vertex1&quot;,x=135.0,y=290.0}, points={135.0,235.0} },{ head={id=&quot;relation16.vertex1&quot;,x=135.0,y=290.0}, tail={id=&quot;TagToAccessorComposite.trigger&quot;,x=710.0,y=235.0}, points={635.0,290.0,635.0,225.0} } }">
        </property>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="{300.0, 235.0}">
        </vertex>
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;relation8.vertex1&quot;,x=480.0,y=145.0}, tail={id=&quot;relation.vertex1&quot;,x=300.0,y=235.0}, points={300.0,145.0} },{ head={id=&quot;ImageReader.output&quot;,x=215.0,y=235.0}, tail={id=&quot;relation.vertex1&quot;,x=300.0,y=235.0}, points={} },{ head={id=&quot;ObjectRecognizer.input&quot;,x=375.0,y=225.0}, tail={id=&quot;relation.vertex1&quot;,x=300.0,y=235.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="{480.0, 145.0}">
        </vertex>
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;ImageAnnotate.image&quot;,x=1240.0,y=210.0}, tail={id=&quot;relation8.vertex1&quot;,x=480.0,y=145.0}, points={1155.0,230.0,1155.0,145.0} } }">
        </property>
    </relation>
    <relation name="relation17" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;GraphicOverlay.reset&quot;,x=1045.0,y=200.0}, tail={id=&quot;IndexGenerator.reset&quot;,x=550.0,y=175.0}, points={965.0,190.0,965.0,165.0} } }">
        </property>
    </relation>
    <relation name="relation18" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;MutableAccessor.schema&quot;,x=870.0,y=255.0}, tail={id=&quot;JavaScript2.spec&quot;,x=1385.0,y=255.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;ImageAnnotate.output&quot;,x=1240.0,y=210.0}, tail={id=&quot;JavaScript2.image&quot;,x=1385.0,y=255.0}, points={1320.0,210.0,1320.0,245.0} } }">
        </property>
    </relation>
    <relation name="relation13" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;Browser.resources&quot;,x=1545.0,y=255.0}, tail={id=&quot;JavaScript2.resources&quot;,x=1385.0,y=255.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation15" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;Browser.html&quot;,x=1545.0,y=255.0}, tail={id=&quot;JavaScript2.html&quot;,x=1385.0,y=255.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;TagToAccessorComposite.index&quot;,x=710.0,y=235.0}, tail={id=&quot;IndexGenerator.index&quot;,x=550.0,y=175.0}, points={640.0,245.0,640.0,185.0} } }">
        </property>
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;TagToAccessorComposite.accessor&quot;,x=710.0,y=235.0}, tail={id=&quot;MutableAccessor.accessor&quot;,x=870.0,y=255.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;GraphicOverlay.translation&quot;,x=1045.0,y=200.0}, tail={id=&quot;TagToAccessorComposite.translation&quot;,x=710.0,y=235.0}, points={795.0,200.0,795.0,225.0} } }">
        </property>
    </relation>
    <link port="ObjectRecognizer.input" relation="relation"/>
    <link port="ObjectRecognizer.tags" relation="relation3"/>
    <link port="ImageAnnotate.graphic" relation="relation6"/>
    <link port="ImageAnnotate.image" relation="relation8"/>
    <link port="ImageAnnotate.translate" relation="relation7"/>
    <link port="ImageAnnotate.output" relation="relation5"/>
    <link port="ImageReader.output" relation="relation"/>
    <link port="ImageReader.trigger" relation="relation16"/>
    <link port="GraphicOverlay.svg" relation="relation6"/>
    <link port="GraphicOverlay.latestTranslation" relation="relation7"/>
    <link port="GraphicOverlay.reset" relation="relation17"/>
    <link port="GraphicOverlay.translation" relation="relation4"/>
    <link port="GraphicOverlay.json" relation="relation2"/>
    <link port="TestSpontaneous.output" relation="relation16"/>
    <link port="MutableAccessor.accessor" relation="relation10"/>
    <link port="MutableAccessor.control" relation="relation11"/>
    <link port="MutableAccessor.data" relation="relation2"/>
    <link port="MutableAccessor.schema" relation="relation18"/>
    <link port="IndexGenerator.tags" relation="relation3"/>
    <link port="IndexGenerator.reset" relation="relation17"/>
    <link port="IndexGenerator.index" relation="relation9"/>
    <link port="Browser.html" relation="relation15"/>
    <link port="Browser.resources" relation="relation13"/>
    <link port="Browser.post" relation="relation11"/>
    <link port="Display.input" relation="relation11"/>
    <link port="JavaScript2.image" relation="relation5"/>
    <link port="JavaScript2.spec" relation="relation18"/>
    <link port="JavaScript2.html" relation="relation15"/>
    <link port="JavaScript2.resources" relation="relation13"/>
    <link port="TagToAccessorComposite.index" relation="relation9"/>
    <link port="TagToAccessorComposite.trigger" relation="relation16"/>
    <link port="TagToAccessorComposite.tags" relation="relation3"/>
    <link port="TagToAccessorComposite.translation" relation="relation4"/>
    <link port="TagToAccessorComposite.accessor" relation="relation10"/>
    <link relation1="relation" relation2="relation8"/>
</entity>
